#!/bin/bash
# rerandr3 - Bash multimonitor handler daemon
# by Vladimir Kudrya
# https://github.com/Vladimir-csp/
#
# This script is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version. See <http://www.gnu.org/licenses/>.

# syntax:
#
# 	rerandr command
#
# where command is one of:
#
# 	save - save current uniqe monitor setup based on output names,
# 		monitor models and serial numbers from EDID data.
#
# 	restore - if current monitor setup is known, apply stored config.
# 		If setup is unknown, try to disable everything disconnected and
# 		enable and stack everything connected.
#
# 	daemon - launch user session daemon for automatic triggering.
#
# 	trigger-save - tell daemon to do save.
#
# 	trigger-restore - tell daemon to restore configuration.
#
# to use rerandr3 in 'full auto', create udev rule:
# KERNEL=="card0", SUBSYSTEM=="drm", RUN+="/usr/local/bin/rerandr3 trigger-restore"
# where "/usr/local/bin/rerandr3" is the full path to this script


# hook trigger boundary in pixel quantity (width*height)
# 1366 * 768 = 1049088
PIXEL_TRIGGER=1100000

SOCKET="/tmp/rerandr3.fifo"
DAEMON_LOG="$HOME/.rerandr3.log"

# check for needed tools
for BINARY in xrandr xxd sed tr xdpyinfo
do
	which $BINARY >/dev/null || { echo "$BINARY not found!" >&2 ; exit 1 ;}
done

prepare_confdir(){
	if [ -n "$XDG_CONFIG_HOME" ]
	then
		CONF_DIR="$XDG_CONFIG_HOME/rerandr3"
	else
		CONF_DIR="$HOME/.config/rerandr3"
	fi
	mkdir -p "$CONF_DIR"

	[ -d "$CONF_DIR" -a -w "$CONF_DIR" ] || { echo "Could not access config directory \"$CONF_DIR\"!" >&2 ; exit 1 ;}
}

prepare_pipe(){
	[ ! -p "$SOCKET" ] && mkfifo "$SOCKET"
	[ "$(stat -c %a "$SOCKET")" != "666" ] && chmod 666 "$SOCKET"
	[ ! -p "$SOCKET" -a "$(stat -c %a "$SOCKET")" != "666" ] && { echo "Could not prepare named pipe \"$SOCKET\"!" >&2 ; exit 1 ;}
}
get_data(){
	OUTPUT_NUM=-1
	unset OUTPUT STATUS ROLE POSITION POSITION_X POSITION_Y CRTC MODEL SERIAL MODE_CURRENT MODE_PREFERRED EDID EDID_CATCH RANDR ROTATION REFLECTION
	OIFS=$IFS
	echo "Gathering data..."
	IFS=
	while read LINE ; do
		# get output name and status
		if echo "$LINE" | grep -q '^[[:alnum:]_-]\+[[:space:]]\+\(connected\|disconnected\)'
		then
			OUTPUT_NUM=$(( $OUTPUT_NUM + 1 ))
			OUTPUT[$OUTPUT_NUM]="$(echo -n "$LINE" | grep -o '^[^[:space:]]\+')"
			STATUS[$OUTPUT_NUM]="$(echo -n "$LINE" | grep -ow 'connected\|disconnected')"
			ROLE[$OUTPUT_NUM]="$(echo -n "$LINE" | grep -ow 'primary')"
			MODE_CURRENT[$OUTPUT_NUM]="$(echo -n "$LINE" | grep -o '[0-9]\+x[0-9]\+[+-][0-9]\+[+-][0-9]\+' | grep -o '[0-9]\+x[0-9]\+')"
			# everything else is irrelevant if output is disconnected
			if [ "${STATUS[$OUTPUT_NUM]}" = "connected" ]
			then
				POSITION[$OUTPUT_NUM]="$(echo -n "$LINE" | grep -o '[0-9]\+x[0-9]\+[+-][0-9]\+[+-][0-9]\+' | grep -o '[+-][0-9]\+[+-][0-9]\+')"
				POSITION_X[$OUTPUT_NUM]="$(echo -n ${POSITION[$OUTPUT_NUM]} | grep -o '[+-][0-9]\+' | head -n 1)"
				POSITION_Y[$OUTPUT_NUM]="$(echo -n ${POSITION[$OUTPUT_NUM]} | grep -o '[+-][0-9]\+' | tail -n 1)"
				# active reflect and rotation settings are between ") ... ("
				RANDR[$OUTPUT_NUM]="${LINE#*)}"
				RANDR[$OUTPUT_NUM]="${RANDR[$OUTPUT_NUM]%%(*}"
				ROTATION[$OUTPUT_NUM]="$(echo -n "${RANDR[$OUTPUT_NUM]}" | grep -o 'normal\|right\|inverted|\left')"
				# 'x' and 'y' in xrandr output may vary in case
				echo -n "${RANDR[$OUTPUT_NUM]}" | grep -qiw 'x' && REFLECTION[$OUTPUT_NUM]="x"
				echo -n "${RANDR[$OUTPUT_NUM]}" | grep -qiw 'y' && REFLECTION[$OUTPUT_NUM]="${REFLECTION[$OUTPUT_NUM]}y"
				[ -z "${REFLECTION[$OUTPUT_NUM]}" ] && REFLECTION[$OUTPUT_NUM]="normal"
			fi
			continue
		fi

		# get CRTC
		# using crtc in saved configs works around xrandr position restore bug.
		if echo "$LINE" | grep -q '^[[:space:]]\+CRTC:'
		then
			CRTC[$OUTPUT_NUM]="$(echo "$LINE" | grep -o '[0-9]\+')"
			continue
		fi

		# trigger EDID catching
		if echo "$LINE" | grep -q '^[[:space:]]\+EDID:'
		then
			EDID_CATCH=1
			continue
		fi

		# catch and combine EDID strings
		if [ "$EDID_CATCH" = "1" ]
		then
			if echo "$LINE" | grep -q '^[[:space:]]\+[[:xdigit:]]\+$'
			then
				EDID[$OUTPUT_NUM]="${EDID[$OUTPUT_NUM]}$(echo -n "$LINE" | grep -o '[[:xdigit:]]\+')"
				continue
			else
				EDID_CATCH=0
				EDID[$OUTPUT_NUM]=$(echo ${EDID[$OUTPUT_NUM]} | fold -w2 | paste -sd\ )
				MODEL[$OUTPUT_NUM]="${EDID[$OUTPUT_NUM]##*fc}"
				MODEL[$OUTPUT_NUM]="${MODEL[$OUTPUT_NUM]%%0a*}"
				MODEL[$OUTPUT_NUM]="$(echo ${MODEL[$OUTPUT_NUM]} | xxd -r -p | tr -cd '\11\12\15\40-\176' | sed 's/[^a-zA-Z0-9_[:space:]-]//g;s/^[[:space:]]\+\|[[:space:]]\+$//g;s/[[:space:]]\+/_/g')"
				SERIAL[$OUTPUT_NUM]="${EDID[$OUTPUT_NUM]##*ff}"
				SERIAL[$OUTPUT_NUM]="${SERIAL[$OUTPUT_NUM]%%0a*}"
				SERIAL[$OUTPUT_NUM]="$(echo ${SERIAL[$OUTPUT_NUM]} | xxd -r -p | tr -cd '\11\12\15\40-\176' | sed 's/[^a-zA-Z0-9_[:space:]-]//g;s/^[[:space:]]\+\|[[:space:]]\+$//g;s/[[:space:]]\+/_/g')"
				# do not skip cycle here, this is not EDID line
			fi
		fi

		# get preferred mode
		if echo "$LINE" | grep -q '^[[:space:]]\+[0-9]\+x[0-9]\+'
		then
			if echo "$LINE" | grep -q '\+preferred'
			then
				MODE_PREFERRED[$OUTPUT_NUM]="$(echo "$LINE" | grep -o '[0-9]\+x[0-9]\+')"
			fi
			continue
		fi
	done < <(xrandr --verbose)
	IFS=$OIFS
	DPI="$(xdpyinfo | grep 'resolution:' | grep -o '[0-9]\+x[0-9]\+')"
	DIMENSIONS="$(xdpyinfo | grep dimensions | grep -o '[0-9]\+x[0-9]\+' | head -n 1)"
}

dump_args(){
	for OUTPUT_NUM in `seq 0 $(( ${#OUTPUT[@]} - 1 ))`
	do
		echo -n "--output ${OUTPUT[$OUTPUT_NUM]} "
		if [ -z "${MODE_CURRENT[$OUTPUT_NUM]}" ]
		then
			echo -n "--off "
		else
			echo -n "--mode ${MODE_CURRENT[$OUTPUT_NUM]} --pos ${POSITION_X[$OUTPUT_NUM]}x${POSITION_Y[$OUTPUT_NUM]} --rotate ${ROTATION[$OUTPUT_NUM]} --reflect ${REFLECTION[$OUTPUT_NUM]} --crtc ${CRTC[$OUTPUT_NUM]} "
			[ "${ROLE[$OUTPUT_NUM]}" = "primary" ] && echo -n "--primary "
		fi
	done
	echo -n "--dpi $DPI"
}

dump_id(){
	FORMATTER=
	for OUTPUT_NUM in `seq 0 $(( ${#OUTPUT[@]} - 1 ))`
	do
		if [ "${STATUS[$OUTPUT_NUM]}" = "connected" ]
		then
			[ -n "$FORMATTER" ] && echo -n '-'
			FORMATTER=1
			echo -n "${OUTPUT[$OUTPUT_NUM]}"
			[ -n "${MODEL[$OUTPUT_NUM]}" ] && echo -n "-${MODEL[$OUTPUT_NUM]}"
			[ -n "${SERIAL[$OUTPUT_NUM]}" ] && echo -n "-${SERIAL[$OUTPUT_NUM]}"
#			[ -n "${SERIAL[$OUTPUT_NUM]}" -a -z "$(echo ${OUTPUT[$OUTPUT_NUM]} | grep LVDS)" ] && echo -n "-${SERIAL[$OUTPUT_NUM]}"
		fi
	done
}

save_setup(){
	SETUP_ID=$(dump_id)
	SETUP_ARGS=$(dump_args)
	echo "Saving configuration for setup \"${SETUP_ID}\"..."
	echo "$SETUP_ARGS" > "$CONF_DIR/${SETUP_ID}.rerandr"
}

apply_setup(){
	SETUP_ID=$(dump_id)
	SETUP_ARGS=$(dump_args)

	if [ -r "$CONF_DIR/${SETUP_ID}.rerandr" ]
	then
		echo "Applying configuration for setup \"${SETUP_ID}\"..."
		SAVED_SETUP_ARGS="$(cat "$CONF_DIR/${SETUP_ID}.rerandr")"
		if [ "$SETUP_ARGS" = "$SAVED_SETUP_ARGS" ]
		then
			echo "Nothing to do."
		else
			# disable everything preserving framebuffer size
			# this works around xrandr CRTC allocation bug, also preserving window positions
			DISABLE_ARGS="--fb $DIMENSIONS"
			for OUTPUT_NUM in `seq 0 $(( ${#OUTPUT[@]} - 1 ))`
			do
				DISABLE_ARGS="$DISABLE_ARGS --output ${OUTPUT[$OUTPUT_NUM]} --off"
			done
			xrandr $DISABLE_ARGS
			# disable disconnected outputs preserving framebuffer size
			#for OUTPUT_NUM in `seq 0 $(( ${#OUTPUT[@]} - 1 ))`
			#do
			#	if [ "${STATUS[$OUTPUT_NUM]}" = "disconnected" -a -n "${MODE_CURRENT[$OUTPUT_NUM]}" ]
			#	then
			#		echo "Disabling disconnected output \"${OUTPUT[$OUTPUT_NUM]}\"..."
			#		xrandr --fb "$DIMENSIONS" --output "${OUTPUT[$OUTPUT_NUM]}" --off
			#	fi
			#done

			# sanitize args from config for security
			NEW_ARGS="$(cat "$CONF_DIR/${SETUP_ID}.rerandr" | tr -d ';&')"
			xrandr $NEW_ARGS
			applyhooks
		fi
	else
		echo "No configuration found for setup \"${SETUP_ID}\"."
		# disable disconnected outputs preserving framebuffer size
		for OUTPUT_NUM in `seq 0 $(( ${#OUTPUT[@]} - 1 ))`
		do
			if [ "${STATUS[$OUTPUT_NUM]}" = "disconnected" -a -n "${MODE_CURRENT[$OUTPUT_NUM]}" ]
			then
				echo "Disabling disconnected output \"${OUTPUT[$OUTPUT_NUM]}\"..."
				xrandr --fb "$DIMENSIONS" --output "${OUTPUT[$OUTPUT_NUM]}" --off
			fi
		done
		# enable connected outputs stacking to the right
		LAST_CONNECTED=
		for OUTPUT_NUM in `seq 0 $(( ${#OUTPUT[@]} - 1 ))`
		do
			if [ "${STATUS[$OUTPUT_NUM]}" = "connected" -a -z "${MODE_CURRENT[$OUTPUT_NUM]}" ]
			then
				echo "Enabling connected output \"${OUTPUT[$OUTPUT_NUM]}\"..."
				xrandr --output "${OUTPUT[$OUTPUT_NUM]}" --auto
			fi
		done
		applyhooks
	fi
	
}

##############################################
#### window hooks
##############################################

hooks() {
# do things on every switch
echo "Applying general hooks."
#killall -USR1 conky
}

smallhooks() {
# do things if screen width is less than $PIXEL_TRIGGER
echo "Applying small screen hooks."
#wmctrl -xr Iceweasel	-b "add,maximized_horz,maximized_vert"
#wmctrl -xr Icedove		-b "add,maximized_horz,maximized_vert"
#wmctrl -xr Spacefm		-b "add,maximized_horz,maximized_vert"
}

largehooks() {
# do things if screen width is greater than $PIXEL_TRIGGER
echo "Applying large screen hooks."
#wmctrl -xr Iceweasel	-b "remove,maximized_vert,maximized_horz"
#wmctrl -xr Icedove	-b "remove,maximized_vert,maximized_horz"
#wmctrl -xr Spacefm	-b "remove,maximized_vert,maximized_horz"
#wmctrl -xr Iceweasel	-e "0,-1,-1,1280,$HEIGHT"
#wmctrl -xr Icedove	-e "0,-1,-1,1280,$HEIGHT"
#wmctrl -xr Spacefm	-e "0,-1,-1,1280,$HEIGHT"
}

applyhooks() {
# calculate dimensions and apply hooks
DIMENSIONS="$(xdpyinfo | grep dimensions | grep -o '[0-9]\+x[0-9]\+' | head -n 1)"
WIDTH="$(echo "$DIMENSIONS" | cut -d x -f 1)"
HEIGHT="$(echo "$DIMENSIONS" | cut -d x -f 2)"
PIXELS="$(( $WIDTH * $HEIGHT ))"
echo "Pixel quantity: $PIXELS"
if [ "$PIXELS" -gt "$PIXEL_TRIGGER" ] ; then
	hooks
	largehooks
else
	hooks
	smallhooks
fi
}



if [ "$1" = "save" ]
then
	prepare_confdir
	get_data
	save_setup
elif [ "$1" = "restore" ]
then
	prepare_confdir
	get_data
	apply_setup
elif [ "$1" = "trigger-save" ]
then
	[ -p "$SOCKET" -a "$(stat -c %a "$SOCKET")" = "666" ] && echo save > "$SOCKET"
	true
elif [ "$1" = "trigger-restore" ]
then
	[ -p "$SOCKET" -a "$(stat -c %a "$SOCKET")" = "666" ] && echo restore > "$SOCKET"
	true
elif [ "$1" = "daemon" ]
then
	prepare_pipe 2>&1 | tee -a "$DAEMON_LOG"
	# trap to kill all child processes of script
	trap 'kill $(jobs -p) &>/dev/null ; echo deadbeef > $SOCKET' EXIT
	trap 'kill $(jobs -p) &>/dev/null ; echo deadbeef > $SOCKET' SIGHUP
	trap 'kill $(jobs -p) &>/dev/null ; echo deadbeef > $SOCKET' SIGINT
	"$0" restore 2>&1 | tee -a "$DAEMON_LOG"
	while true
	do
		echo "Waiting for socket trigger..."
		ACTION="$(cat "$SOCKET" | head -c 8)"
		if [ "$ACTION" = "save" ]
		then
			"$0" save
			ACTION=
		elif [ "$ACTION" = "restore" ]
		then
			"$0" restore
			ACTION=
		else
			echo "Unknown action."
			ACTION=
			sleep 5s
		fi
	done 2>&1 | tee -a "$DAEMON_LOG"
fi
