#!/bin/bash
# rerandr3 - Bash multimonitor handler daemon
# by Vladimir Kudrya
# https://github.com/Vladimir-csp/
#
# This script is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version. See <http://www.gnu.org/licenses/>.

# syntax:
#
# 	rerandr command
#
# where command is one of:
#
# 	save - save current uniqe monitor setup based on output names,
# 		monitor models and serial numbers from EDID data.
#
# 	restore - if current monitor setup is known, apply stored config.
# 		If setup is unknown, try to disable everything disconnected and
# 		enable and stack everything connected.
#
# 	show - dump setup ID and xrandr arguments of current state.
#
# 	daemon - launch user session daemon for automatic triggering.
#
# 	trigger-save - tell daemon to do save.
#
# 	trigger-restore - tell daemon to restore configuration.
#
# 	insert-udev - insert udev rule for auto triggering.
#
# to use rerandr3 in 'full auto', create udev rule:
# KERNEL=="card0", SUBSYSTEM=="drm", RUN+="/usr/local/bin/rerandr3 trigger-restore"
# where "/usr/local/bin/rerandr3" is the full path to this script


# hook trigger boundary in pixel quantity (width*height)
# 1366 * 768 = 1049088
PIXEL_TRIGGER=1100000

SOCKET="/tmp/rerandr3.fifo"
DAEMON_LOG="$HOME/.rerandr3.log"
UDEV_RULE_FILE="/etc/udev/rules.d/95-rerandr3-monitor-trigger.rules"
UDEV_RULE='KERNEL=="card0", SUBSYSTEM=="drm",  RUN+="/usr/local/bin/rerandr3 trigger-restore"'

# check for needed tools
for BINARY in xrandr xxd sed tr xdpyinfo
do
	which $BINARY >/dev/null || { echo "$BINARY not found!" >&2 ; exit 1 ;}
done

prepare_confdir(){
	if [ -n "$XDG_CONFIG_HOME" ]
	then
		CONF_DIR="$XDG_CONFIG_HOME/rerandr3"
	else
		CONF_DIR="$HOME/.config/rerandr3"
	fi
	mkdir -p "$CONF_DIR"

	[ -d "$CONF_DIR" -a -w "$CONF_DIR" ] || { echo "Could not access config directory \"$CONF_DIR\"!" >&2 ; exit 1 ;}
}

prepare_pipe(){
	[ ! -p "$SOCKET" ] && mkfifo "$SOCKET"
	[ "$(stat -c %a "$SOCKET")" != "666" ] && chmod 666 "$SOCKET"
	[ ! -p "$SOCKET" -a "$(stat -c %a "$SOCKET")" != "666" ] && { echo "Could not prepare named pipe \"$SOCKET\"!" >&2 ; exit 1 ;}
}
get_data(){
	OUTPUT_NUM=-1
	unset OUTPUT STATUS ROLE POSITION POSITION_X POSITION_Y CRTC MODEL SERIAL MODE_CURRENT MODE_PREFERRED EDID EDID_CATCH RANDR ROTATION REFLECTION GAMMA BRIGHTNESS TRANSFORM
	OIFS=$IFS
	echo "Gathering data..."
	IFS=
	while read LINE ; do
		# get output name and status
		if echo "$LINE" | grep -q '^[[:alnum:]_-]\+[[:space:]]\+\(connected\|disconnected\)'
		then
			OUTPUT_NUM=$(( $OUTPUT_NUM + 1 ))
			OUTPUT[$OUTPUT_NUM]="$(echo -n "$LINE" | grep -o '^[^[:space:]]\+')"
			STATUS[$OUTPUT_NUM]="$(echo -n "$LINE" | grep -ow 'connected\|disconnected')"
			ROLE[$OUTPUT_NUM]="$(echo -n "$LINE" | grep -ow 'primary')"
			MODE_CURRENT[$OUTPUT_NUM]="$(echo -n "$LINE" | grep -o '[0-9]\+x[0-9]\+[+-][0-9]\+[+-][0-9]\+' | grep -o '[0-9]\+x[0-9]\+')"
			# everything else is irrelevant if output is disconnected
			if [ "${STATUS[$OUTPUT_NUM]}" = "connected" ]
			then
				POSITION[$OUTPUT_NUM]="$(echo -n "$LINE" | grep -o '[0-9]\+x[0-9]\+[+-][0-9]\+[+-][0-9]\+' | grep -o '[+-][0-9]\+[+-][0-9]\+')"
				POSITION_X[$OUTPUT_NUM]="$(echo -n ${POSITION[$OUTPUT_NUM]} | grep -o '[+-][0-9]\+' | head -n 1)"
				POSITION_Y[$OUTPUT_NUM]="$(echo -n ${POSITION[$OUTPUT_NUM]} | grep -o '[+-][0-9]\+' | tail -n 1)"
				# active reflect and rotation settings are between ") ... ("
				RANDR[$OUTPUT_NUM]="${LINE#*)}"
				RANDR[$OUTPUT_NUM]="${RANDR[$OUTPUT_NUM]%%(*}"
				ROTATION[$OUTPUT_NUM]="$(echo -n "${RANDR[$OUTPUT_NUM]}" | grep -o 'normal\|right\|inverted|\left')"
				# 'x' and 'y' in xrandr output may vary in case
				echo -n "${RANDR[$OUTPUT_NUM]}" | grep -qiw 'x' && REFLECTION[$OUTPUT_NUM]="x"
				echo -n "${RANDR[$OUTPUT_NUM]}" | grep -qiw 'y' && REFLECTION[$OUTPUT_NUM]="${REFLECTION[$OUTPUT_NUM]}y"
				[ -z "${REFLECTION[$OUTPUT_NUM]}" ] && REFLECTION[$OUTPUT_NUM]="normal"
			fi
			continue
		fi

		# get CRTC
		# using crtc in saved configs works around xrandr position restore bug.
		if echo "$LINE" | grep -q '^[[:space:]]\+CRTC:'
		then
			CRTC[$OUTPUT_NUM]="$(echo "$LINE" | grep -o '[0-9]\+')"
			continue
		fi

		# trigger EDID catching
		if echo "$LINE" | grep -q '^[[:space:]]\+EDID:'
		then
			EDID_CATCH=1
			continue
		fi

		# catch and combine EDID strings
		if [ "$EDID_CATCH" = "1" ]
		then
			if echo "$LINE" | grep -q '^[[:space:]]\+[[:xdigit:]]\+$'
			then
				EDID[$OUTPUT_NUM]="${EDID[$OUTPUT_NUM]}$(echo -n "$LINE" | grep -o '[[:xdigit:]]\+')"
				continue
			else
				unset EDID_CATCH
				EDID[$OUTPUT_NUM]=$(echo ${EDID[$OUTPUT_NUM]} | fold -w2 | paste -sd\ )
				MODEL[$OUTPUT_NUM]="${EDID[$OUTPUT_NUM]##*fc}"
				MODEL[$OUTPUT_NUM]="${MODEL[$OUTPUT_NUM]%%0a*}"
				MODEL[$OUTPUT_NUM]="$(echo ${MODEL[$OUTPUT_NUM]} | xxd -r -p | tr -cd '\11\12\15\40-\176' | sed 's/[^a-zA-Z0-9_[:space:]-]//g;s/^[[:space:]]\+\|[[:space:]]\+$//g;s/[[:space:]]\+/_/g')"
				SERIAL[$OUTPUT_NUM]="${EDID[$OUTPUT_NUM]##*ff}"
				SERIAL[$OUTPUT_NUM]="${SERIAL[$OUTPUT_NUM]%%0a*}"
				SERIAL[$OUTPUT_NUM]="$(echo ${SERIAL[$OUTPUT_NUM]} | xxd -r -p | tr -cd '\11\12\15\40-\176' | sed 's/[^a-zA-Z0-9_[:space:]-]//g;s/^[[:space:]]\+\|[[:space:]]\+$//g;s/[[:space:]]\+/_/g')"
				# do not skip cycle here, we are not on EDID line any more
			fi
		fi

		# trigger transformation catching
		if echo "$LINE" | grep -q '^[[:space:]]\+Transform:'
		then
			TRANSFORM_CATCH=1
			# remove header
			LINE="${LINE#*:}"
			# do not skip, data begins on the same line
		fi
		
		# catch and combine transformation
		if [ "$TRANSFORM_CATCH" = "1" ]
		then
			if echo "$LINE" | grep -q '^[[:space:]]\+[0-9\.[:space:]-]\+$'
			then
				[ -n "${TRANSFORM[$OUTPUT_NUM]}" ] && FORMATTER=',' || unset FORMATTER
				TRANSFORM[$OUTPUT_NUM]="${TRANSFORM[$OUTPUT_NUM]}${FORMATTER}$(echo -n "$LINE" | sed 's/[^0-9\.[:space:]-]//g;s/^[[:space:]]\+\|[[:space:]]\+$//g;s/[[:space:]]\+/,/g')"
				continue
			else
				unset TRANSFORM_CATCH
				# do not skip cycle here, we are not on transform line any more
			fi
		fi

		# get gamma and brightness
		echo "$LINE" | grep -q '^[[:space:]]\+Gamma:' && GAMMA[$OUTPUT_NUM]="$(echo $LINE | sed 's/^[[:space:]]\+Gamma:[[:space:]]*//')"
		echo "$LINE" | grep -q '^[[:space:]]\+Brightness:' && BRIGHTNESS[$OUTPUT_NUM]="$(echo $LINE | sed 's/^[[:space:]]\+Brightness:[[:space:]]*//')"

		# get preferred mode
		if echo "$LINE" | grep -q '^[[:space:]]\+[0-9]\+x[0-9]\+'
		then
			if echo "$LINE" | grep -q '\+preferred'
			then
				MODE_PREFERRED[$OUTPUT_NUM]="$(echo "$LINE" | grep -o '[0-9]\+x[0-9]\+')"
			fi
			continue
		fi
	done < <(xrandr --verbose)
	IFS=$OIFS
	DPI="$(xdpyinfo | grep 'resolution:' | grep -o '[0-9]\+x[0-9]\+')"
	DIMENSIONS="$(xdpyinfo | grep dimensions | grep -o '[0-9]\+x[0-9]\+' | head -n 1)"
}

dump_args(){
	for OUTPUT_NUM in `seq 0 $(( ${#OUTPUT[@]} - 1 ))`
	do
		echo -n "--output ${OUTPUT[$OUTPUT_NUM]} "
		if [ -z "${MODE_CURRENT[$OUTPUT_NUM]}" ]
		then
			echo -n "--off "
		else
			echo -n "--mode ${MODE_CURRENT[$OUTPUT_NUM]} --pos ${POSITION_X[$OUTPUT_NUM]}x${POSITION_Y[$OUTPUT_NUM]} "
			[ -n "${ROTATION[$OUTPUT_NUM]}" ] && echo -n "--rotate ${ROTATION[$OUTPUT_NUM]} "
			[ -n "${REFLECTION[$OUTPUT_NUM]}" ] && echo -n "--reflect ${REFLECTION[$OUTPUT_NUM]} "
			[ -n "${CRTC[$OUTPUT_NUM]}" ] && echo -n "--crtc ${CRTC[$OUTPUT_NUM]} "
			[ -n "${GAMMA[$OUTPUT_NUM]}" ] && echo -n "--gamma ${GAMMA[$OUTPUT_NUM]} "
			[ -n "${BRIGHTNESS[$OUTPUT_NUM]}" ] && echo -n "--brightness ${BRIGHTNESS[$OUTPUT_NUM]} "
			[ -n "${TRANSFORM[$OUTPUT_NUM]}" ] && echo -n "--transform ${TRANSFORM[$OUTPUT_NUM]} "
			[ "${ROLE[$OUTPUT_NUM]}" = "primary" ] && echo -n "--primary "
		fi
	done
	echo -n "--dpi $DPI"
}

dump_id(){
	FORMATTER=
	for OUTPUT_NUM in `seq 0 $(( ${#OUTPUT[@]} - 1 ))`
	do
		if [ "${STATUS[$OUTPUT_NUM]}" = "connected" ]
		then
			[ -n "$FORMATTER" ] && echo -n '-'
			FORMATTER=1
			echo -n "${OUTPUT[$OUTPUT_NUM]}"
			[ -n "${MODEL[$OUTPUT_NUM]}" ] && echo -n "-${MODEL[$OUTPUT_NUM]}"
			[ -n "${SERIAL[$OUTPUT_NUM]}" ] && echo -n "-${SERIAL[$OUTPUT_NUM]}"
#			[ -n "${SERIAL[$OUTPUT_NUM]}" -a -z "$(echo ${OUTPUT[$OUTPUT_NUM]} | grep LVDS)" ] && echo -n "-${SERIAL[$OUTPUT_NUM]}"
		fi
	done
}

save_setup(){
	SETUP_ID=$(dump_id)
	SETUP_ARGS=$(dump_args)
	echo "Saving configuration for setup \"${SETUP_ID}\"..."
	echo "$SETUP_ARGS" > "$CONF_DIR/${SETUP_ID}.rerandr"
}

show_setup(){
	SETUP_ID=$(dump_id)
	SETUP_ARGS=$(dump_args)
	echo "${SETUP_ID}"
	echo "$SETUP_ARGS"
}

apply_saved(){
	# sanitize args from config for security
	SAVED_SETUP_ARGS="$(cat "$CONF_DIR/${SETUP_ID}.rerandr" | tr -d ';&')"
	if [ "$SETUP_ARGS" = "$SAVED_SETUP_ARGS" ]
	then
		echo "Nothing to do."
	else
		# disable everything preserving framebuffer size
		# this works around xrandr CRTC allocation bug, also preserving window positions
		DISABLE_ARGS="--fb $DIMENSIONS"
		for OUTPUT_NUM in `seq 0 $(( ${#OUTPUT[@]} - 1 ))`
		do
			DISABLE_ARGS="$DISABLE_ARGS --output ${OUTPUT[$OUTPUT_NUM]} --off"
		done
		xrandr $DISABLE_ARGS
		# disable disconnected outputs preserving framebuffer size
		#for OUTPUT_NUM in `seq 0 $(( ${#OUTPUT[@]} - 1 ))`
		#do
		#	if [ "${STATUS[$OUTPUT_NUM]}" = "disconnected" -a -n "${MODE_CURRENT[$OUTPUT_NUM]}" ]
		#	then
		#		echo "Disabling disconnected output \"${OUTPUT[$OUTPUT_NUM]}\"..."
		#		xrandr --fb "$DIMENSIONS" --output "${OUTPUT[$OUTPUT_NUM]}" --off
		#	fi
		#done

		# apply
		xrandr $SAVED_SETUP_ARGS
		if [ "$?" = "0" ]
		then
			applyhooks
		else
			echo "Failed to apply saved configuration, trying auto..."
			apply_auto
		fi
	fi
}

apply_auto(){
	# disable disconnected outputs preserving framebuffer size
	# find some connected and enabled output
	LAST_CONNECTED=
	for OUTPUT_NUM in `seq 0 $(( ${#OUTPUT[@]} - 1 ))`
	do
		if [ "${STATUS[$OUTPUT_NUM]}" = "disconnected" -a -n "${MODE_CURRENT[$OUTPUT_NUM]}" ]
		then
			echo "Disabling disconnected output \"${OUTPUT[$OUTPUT_NUM]}\"..."
			xrandr --fb "$DIMENSIONS" --output "${OUTPUT[$OUTPUT_NUM]}" --off
		elif [ "${STATUS[$OUTPUT_NUM]}" = "connected" -a -n "${MODE_CURRENT[$OUTPUT_NUM]}" ]
		then
			LAST_CONNECTED="${OUTPUT[$OUTPUT_NUM]}"
		fi
	done
	
	# enable connected outputs stacking to the right
	for OUTPUT_NUM in `seq 0 $(( ${#OUTPUT[@]} - 1 ))`
	do
		if [ "${STATUS[$OUTPUT_NUM]}" = "connected" -a -z "${MODE_CURRENT[$OUTPUT_NUM]}" ]
		then
			echo "Enabling connected output \"${OUTPUT[$OUTPUT_NUM]}\"..."
			[ -n "$LAST_CONNECTED" ] && xrandr --output "${OUTPUT[$OUTPUT_NUM]}" --auto --right-of "$LAST_CONNECTED"
			[ -z "$LAST_CONNECTED" ] && xrandr --output "${OUTPUT[$OUTPUT_NUM]}" --auto
			LAST_CONNECTED="${OUTPUT[$OUTPUT_NUM]}"
		fi
	done
	applyhooks
}

apply_setup(){
	SETUP_ID=$(dump_id)
	SETUP_ARGS=$(dump_args)

	if [ -r "$CONF_DIR/${SETUP_ID}.rerandr" ]
	then
		echo "Applying configuration for setup \"${SETUP_ID}\"..."
		apply_saved
	else
		echo "No configuration found for setup \"${SETUP_ID}\"."
		apply_auto
	fi
}

##############################################
#### window hooks
##############################################

hooks() {
# do things on every switch
echo "Applying general hooks."
#killall -USR1 conky
}

smallhooks() {
# do things if screen width is less than $PIXEL_TRIGGER
echo "Applying small screen hooks."
#wmctrl -xr Iceweasel	-b "add,maximized_horz,maximized_vert"
#wmctrl -xr Icedove		-b "add,maximized_horz,maximized_vert"
#wmctrl -xr Spacefm		-b "add,maximized_horz,maximized_vert"
}

largehooks() {
# do things if screen width is greater than $PIXEL_TRIGGER
echo "Applying large screen hooks."
#wmctrl -xr Iceweasel	-b "remove,maximized_vert,maximized_horz"
#wmctrl -xr Icedove	-b "remove,maximized_vert,maximized_horz"
#wmctrl -xr Spacefm	-b "remove,maximized_vert,maximized_horz"
#wmctrl -xr Iceweasel	-e "0,-1,-1,1280,$HEIGHT"
#wmctrl -xr Icedove	-e "0,-1,-1,1280,$HEIGHT"
#wmctrl -xr Spacefm	-e "0,-1,-1,1280,$HEIGHT"
}

applyhooks() {
# calculate dimensions and apply hooks
DIMENSIONS="$(xdpyinfo | grep dimensions | grep -o '[0-9]\+x[0-9]\+' | head -n 1)"
WIDTH="$(echo "$DIMENSIONS" | cut -d x -f 1)"
HEIGHT="$(echo "$DIMENSIONS" | cut -d x -f 2)"
PIXELS="$(( $WIDTH * $HEIGHT ))"
echo "Pixel quantity: $PIXELS"
if [ "$PIXELS" -gt "$PIXEL_TRIGGER" ] ; then
	hooks
	largehooks
else
	hooks
	smallhooks
fi
}

check_udev(){
	[ ! "$(cat "$UDEV_RULE_FILE" 2>/dev/null)" = "$UDEV_RULE" ] && echo -e "Info:\trerandr3 udev rule \"$UDEV_RULE_FILE\" is missing or invalid.\n\tAutomatic triggering is not possible.\n\tRun \"$(basename "$0") insert-udev\" to insert rule."
}

insert_udev(){
	if [ "$UID" = "0" ]
	then
		echo "$UDEV_RULE" > "$UDEV_RULE_FILE"
		udevadm control --reload
	else
		echo "You are not root. Can not insert udev rule" >&2
		exit 1
	fi	
}

if [ "$1" = "save" ]
then
	prepare_confdir
	get_data
	save_setup
elif [ "$1" = "restore" ]
then
	prepare_confdir
	get_data
	apply_setup
elif [ "$1" = "show" ]
then
	prepare_confdir
	get_data
	show_setup
elif [ "$1" = "trigger-save" ]
then
	[ -p "$SOCKET" -a "$(stat -c %a "$SOCKET")" = "666" ] && echo save > "$SOCKET"
	true
elif [ "$1" = "trigger-restore" ]
then
	[ -p "$SOCKET" -a "$(stat -c %a "$SOCKET")" = "666" ] && echo restore > "$SOCKET"
	true
elif [ "$1" = "daemon" ]
then
	prepare_pipe 2>&1 | tee -a "$DAEMON_LOG"
	check_udev | tee -a "$DAEMON_LOG"
	# trap to kill all child processes of script
	trap 'kill $(jobs -p) &>/dev/null ; echo deadbeef > $SOCKET' EXIT
	trap 'kill $(jobs -p) &>/dev/null ; echo deadbeef > $SOCKET' SIGHUP
	trap 'kill $(jobs -p) &>/dev/null ; echo deadbeef > $SOCKET' SIGINT
	"$0" restore 2>&1 | tee -a "$DAEMON_LOG"
	while true
	do
		echo "Waiting for socket trigger..."
		ACTION="$(cat "$SOCKET" | head -c 8)"
		if [ "$ACTION" = "save" ]
		then
			"$0" save
			ACTION=
		elif [ "$ACTION" = "restore" ]
		then
			"$0" restore
			ACTION=
		else
			echo "Unknown action."
			ACTION=
			sleep 5s
		fi
	done 2>&1 | tee -a "$DAEMON_LOG"
elif [ "$1" = "insert-udev" ]
then
	echo "Will now insert udev rule:
	$UDEV_RULE
in file:
	$UDEV_RULE_FILE
Root access required."
	sudo "$0" root-insert-udev
elif [ "$1" = "root-insert-udev" ]
then
	insert_udev
fi
